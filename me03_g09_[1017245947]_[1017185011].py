# -*- coding: utf-8 -*-
"""ME03-G09-[1017245947]-[1017185011]

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Gw7abhVSN5p9U0YD9DjXrDvbxyvMhVw

# Preparación del dataset de nacimientos 2022.

## 1. Librerias y configuraciones previas
"""

# Cargar datos con colab
from google.colab import drive
import xml.etree.ElementTree as ET
from google.colab import auth
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive
from oauth2client.client import GoogleCredentials
import os

# Tratamiento de datos
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler

#Gráficos
import matplotlib.pyplot as plt
from matplotlib import style
import seaborn as sns

# Matemáticas y estadísticas
import math

# Preparación de datos
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import normalize
from sklearn.cluster import KMeans

# Configuración warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

"""##2. Funciones externas para graficar"""

# Función para graficar atributos en barras, pair plot o box-plot
def multiple_plot(ncols, data, columns, target_var, plot_type, title, rot):
   # Paletas de colores y colores de las gráficas
    paletas = ['nipy_spectral','hsv','jet_r','Paired','Set2','Dark2','tab10','husl','mako']
    color = ['steelblue','forestgreen', 'amber']


    # Parámetros iniciales
    title_dist = 1.1  # Ajusta la distancia vertical del título en el gráfico
    x = -1            # Ubicación en el eje x del gráfico
    y =  0            # Ubicación en el eje y del gráfico
    nrows = 1         # Número inicial de filas


    # Ajustar el número de filas según el tipo de gráfico y la cantidad de columnas
    if isinstance(columns, list):
        nrows = math.ceil(len(columns) / ncols)

    # Crear el gráfico según el tipo especificado
    if ((nrows <= 1 and ncols <= 1) or plot_type == 'scatterplot'):

        # Countplot
        if plot_type == 'countplot':
            # Configurar el gráfico countplot
            fig, axes = plt.subplots(1, 1, figsize=(6, 4))
            ax_cond = axes
            sns.countplot(data=data,
                          x=target_var,
                          ax=axes,
                          palette=paletas[0],
                          zorder=1,
                          order=data[target_var].value_counts().index,
                          alpha=0.8
                          )
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar título
            ax_cond.set_title(title, fontsize=14, fontweight="bold", y=title_dist)

        # Boxplot
        elif plot_type == 'boxplot':
            # Configurar el gráfico boxplot
            fig, axes = plt.subplots(1, 1, figsize=(6, 4))
            ax_cond = axes
            sns.boxplot(data=data,
                        x=columns,
                        y=target_var,
                        ax=axes,
                        palette=paletas[0],
                        zorder=1
                        )
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar título
            ax_cond.set_title(title, fontsize=14, fontweight="bold", y=title_dist)


        # Scatterplot Matrix (Pairplot)
        elif plot_type == 'scatterplot':
            # Configurar el gráfico pairplot
            plot = sns.pairplot(data[columns],
                                palette=paletas[0],
                                diag_kws={'color': color[1]},
                                plot_kws={'color': color[0]},
                                diag_kind='kde'
                                )
            # Ajustar el tamaño del gráfico
            plot.fig.set_size_inches(12, 12)
            # Añadir un título al pairplot
            plot.fig.suptitle(title, fontsize=14, fontweight="bold")
            # Ajustar el diseño para evitar solapamientos
            plt.subplots_adjust(top=0.9)
            # Mostrar el gráfico
            plt.show()

    # Graficar más de un subplot
    else:
        # Crear subplots con el número especificado de filas y columnas
        fig, axes = plt.subplots(nrows, ncols, figsize=(15, (nrows * 3) + 1))

        for i, column in enumerate(columns):
            x = x + 1

            # Reiniciar x e incrementar y si x alcanza el número de columnas
            if x >= ncols:
                y = y + 1
                x = 0

            # Configurar el subplot actual
            if nrows == 1:
                ax_cond = axes[i]
                title_dist = 1.1
            else:
                ax_cond = axes[y, x]

            # Crear el gráfico según el tipo especificado
            if plot_type == 'countplot':
                # Countplot
                sns.countplot(data=data,
                              x=column,
                              ax=ax_cond,
                              palette=paletas[0],
                              zorder=1,
                              edgecolor='black',
                              linewidth=0.5,
                              order=data[column].value_counts().index
                              )

            elif plot_type == 'boxplot':
                # Boxplot
                sns.boxplot(data=data,
                            x=column,
                            y=target_var,
                            ax=ax_cond,
                            palette=paletas[0],
                            zorder=1
                            )

            # Añadir cuadrícula en el eje y
            ax_cond.grid(axis='y', zorder=0)
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar título del subplot
            ax_cond.set_title(column, fontsize=10)
            # Ajustar tamaño de las etiquetas
            ax_cond.tick_params(labelsize=8)
            # Limpiar etiquetas del eje x
            ax_cond.set_xlabel("")

        # Ajustar el diseño y el título general del conjunto de subplots
        fig.tight_layout()
        fig.suptitle(title, fontsize=14, fontweight="bold", y=title_dist - 0.15)
        plt.subplots_adjust(top=0.9)

        # Eliminar subplots sin datos si hay más de una fila
        if nrows > 1:
            for ax in axes.flat:
                if not bool(ax.has_data()):
                    fig.delaxes(ax)  # Eliminar si no hay datos en el subplot

"""##3. Carga del conjunto de datos desde google drive

Este dataset extraido del *DANE* (nombrado: **nac2022.csv** ) contiene información sobre los **nacidos vivos para el 2022**, los cuales serán usados para la predicción de la tasa de natalidad en Colombia, a partir de las diferentes variables.

A continuación una breve descripción de las variables:

****
    
| Campo | Descripción | Ejemplo |
| :--- | :--- |:--- |
| COD_DPTO | Departamento de Nacimiento  | 17=Caldas |
| COD_MUNIC | Municipio de Nacimiento  | 15= Boyaca |
| AREANAC | Área del Nacimiento  | 3 = Rural disperso |
| SIT_PARTO | Sitio de la Parto  | 1= Institución de salud |
| OTRO_SIT | Otro sitio, ¿cuál?  | 2 = Domicilio |
| SEXO | Sexo del nacido vivo  | 1= Masculino |
| PESO_NAC | Peso del nacido vivo, al nacer | 1 = Menos de 1.000 |
| TALLA_NAC | Talla del nacido vivo, al nacer  | 1 = Menos de 20 |
| ANO | Año de la ocurrencia  | 2022 |
| MES | Mes de la ocurrencia  | 03 = Marzo |
| ATEN_PAR | El parto fue atendido por  | 1 = Médico |
| T_GES | Tiempo de gestación del nacido vivo  | 2 = De 22 a 27 |
| T_GES_AGRU_CIE | Tiempo de gestación del nacido vivo ajustado a la agrupación sugerida por la CIE (T_GES_AGRU_CIE)  | 3 = De 28 a 36|
| NUMCONSUL | Número de consultas prenatales que tuvo la madre del nacido vivo  | 00= Ninguna |
| TIPO_PARTO | Tipo de parto de este nacimiento  | 2 = Cesárea |
| MUL_PARTO | Multiplicidad del embarazo  | 3 = Triple |
| APGAR1 | Prueba APGAR al minuto del nacido vivo  | 01 - 10 = Al minuto |
| APGAR2 | Prueba APGAR a los cinco minutos del nacido vivo  | 01 - 10 = A los cinco minutos |
| IDHEMOCLAS | Hemoclasificación del nacido vivo: Grupo Sanguíneo  | 1 = A |
| IDFACTORRH | Hemoclasificación del nacido vivo: Factor RH | 1 = Positivo |
| IDPERTET | De acuerdo con la cultura, pueblo o rasgos físicos, el nacido vivo es reconocido por sus padres como  | 1 = Indígena |
| EDAD_MADRE | Edad de la madre a la fecha del parto | 2 = De 15-19 Años |
| EST_CIVM | Estado conyugal de la madre  | 4 = Está viuda |
| NIV_EDUM | Ultimo nivel de estudio que aprobó la madre  | 2 = Básica primaria |
| ULTCURMAD | Ultimo año o grado aprobado de la madre  | 99 = Sin información |
| CODPRES | País de residencia habitual de la madre en el extranjero  | Colombia |
| CODPTORE | Departamento de residencia habitual de la madre | 05 =	Antioquia |
| CODMUNRE | Municipio de residencia habitual de la madre  | 1 = Cabecera municipal |
| AREA_RES | Área de residencia habitual de la madre  | 2 = Centro poblado |
| N_HIJOSV | Número de hijos nacidos vivos que ha tenido la madre, incluido el presente  | 3 = 3 hijos |
| FECHA_NACM | Fecha de nacimiento del anterior hijo nacido vivo  | 99 = Sin información |
| N_EMB | Número de embarazos, incluido el presente  | 99 = Sin información |
| SEG_SOCIAL | Régimen de seguridad social en salud de la madre | 2 = Subsidiado |
| IDCLASADMI | Entidad Administradora en Salud a la que pertenece la madre  | 1 = Entidad promotora de salud |
| EDAD_PADRE | Edad del padre en años cumplidos a la fecha del nacimiento de este hijo  | 999 = Sin información |
| NIV_EDUP | Nivel educativo del padre, ultimo año de estudio que aprobó el padre | 5 = Media técnica |
| ULTCURPAD | Ultimo año o grado aprobado del padre  | 99 = Sin información |
| PROFESION | Profesión de quien certifica el nacimiento  | 2 = Enfermero(a) |
| TIPOFORMULARIO | Fuente del Certificado  | 1 = Certificado RUAF-ND |

    
****

    
Url origen datos: https://microdatos.dane.gov.co/index.php/catalog/807/data-dictionary/F32?file_name=nac2022
"""

# Autenticación y creación del cliente PyDrive.
  auth.authenticate_user()
  gauth = GoogleAuth()
  gauth.credentials = GoogleCredentials.get_application_default()
  drive = GoogleDrive(gauth)

  # Carga del dataset de acuerdo a su ubicación en google drive  y guardamos en la variable contenido
  downloaded = drive.CreateFile({'id': '1eQB2IcE6WLvL0rIt_AZucnnq0DnsQP-o'})
  contenido = downloaded.GetContentString(encoding='latin1')

  # Imprime el tamaño en Bytes del archivo compartido
  print("Descargados {} bytes".format(len(contenido)))

  with open("nac2022.csv", "w") as f:
      f.write(contenido)

"""###3.1 Cargar el conjunto de datos en un DataFrame"""

# Se cargan los datos en un DataFrame a partir de un archivo .csv

nac = pd.read_csv("nac2022.csv")
pd.set_option('display.max_columns', None)
print("\n Tabla de datos con información de los nacimientos en 2022:")
nac.head()

"""## 4. Identificación de datos"""

# 4.1 Identificando las columnas que tiene la base de datos
nac.columns

# 4.2 Se identifican las variables y su tipo
nac.info()

"""✍ : 📑 Análisis:


*   No se identifican valos 'NaN' o nulos en las columnas del DataFrame
*   Se tienen los siguientes tipos  de variables: float64(6), int64(31), object(2)
*   Se tiene un  total de 38 variables

#5. Limpieza de datos
"""

# 5.1 Borrando columnas que no se utilizaran

nac.drop(['COD_MUNIC','SIT_PARTO','OTRO_SIT','PESO_NAC', 'TALLA_NAC','ANO','ATEN_PAR','T_GES','T_GES_AGRU_CIE',
          'NUMCONSUL','TIPO_PARTO', 'APGAR1', 'APGAR2', 'IDHEMOCLAS', 'IDFACTORRH','ULTCURMAD','CODPRES',
          'CODPTORE', 'CODMUNRE','AREA_RES','N_EMB','IDCLASADMI', 'ULTCURPAD', 'PROFESION', 'TIPOFORMULARIO','FECHA_NACM'], axis='columns', inplace=True)
nac.head(10)

"""✍ : 📑 Análisis:


*   Se eliminan las variables que a consideración del equipo de trabajo no aportan información relevante de acuerdo al objetivo del proyecto planteado. Sin embargo, podrían tenerse en cuenta posteriormente de acuerdo a los resultados derivados de los modelos generados, bien sea como replanteamiento de los mismos o analisis de los resultados.
*   Se elimina un total (26) variables.
*   Se procesarán (13) variables.



"""

# 5.2 Se genera un df para la creación los datasets de los modelos (sin descodificar variables)
nac_1 = pd.DataFrame(nac)
pd.set_option('display.max_columns', None)
print("\n Tabla de datos con información de los nacimientos en 2022:")

# Se reemplazan las celdas que no contienen información y que están codificadas con 99 y 999
nac_1 = nac_1.replace(99, np.nan)
nac_1 = nac_1.replace(999, np.nan)
nac_1.head()

# 5.3 Se identifican los valores 'NaN' en cada columna
print("Valores nulos por columna:")
print(nac_1.isnull().sum())

# 5.4 Se imputan los valores de la media sobre los valores 'NaN'
nac_1 = nac_1.fillna(nac_1.mean()).round(2)
nac_1

# 5.5 Se verifican de nuevamente los 'NaN' por columna
print("Valores nulos por columna:")
print(nac_1.isnull().sum())

# 5.6 Verificación de registros duplicados
nac.loc[nac_1.duplicated()]

"""- **Nota**:

Debido a que para este dataset en particular, se tiene que cada registro es único por cada nacimiento, no se van a eliminar duplicados porque alterariamos la información contenida.

# 6. Descodificación de  variables sobre el dataFrame Original
"""

# 6.1 Reemplazo de códigos en el conjunto de datos

#1. Descodificando la variable 'COD_DPTO' = Codigo departamento
amazonia_map = {18: 'Amazonia', 41: 'Amazonia', 73: 'Amazonia', 86: 'Amazonia', 91: 'Amazonia'}
andina_map = {5: 'Andina', 11: 'Andina', 15: 'Andina', 17: 'Andina', 25: 'Andina', 54 :'Andina',63: 'Andina', 66: 'Andina', 68: 'Andina'}
caribe_map = {8: 'Caribe', 13: 'Caribe', 20: 'Caribe',23: 'Caribe', 44: 'Caribe', 47: 'Caribe', 70: 'Caribe', 88: 'Caribe'}
llanos_map = {50:'Llanos', 81:'Llanos', 85:'Llanos', 94:'Llanos', 95:'Llanos', 97:'Llanos', 99:'Llanos'}
pacifico_map = {19:'Pacifico', 27:'Pacifico', 52:'Pacifico', 76:'Pacifico'}

nac['COD_DPTO'] = nac['COD_DPTO'].replace(amazonia_map)  # Reemplazo de región amazonia
nac['COD_DPTO'] = nac['COD_DPTO'].replace(andina_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(caribe_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(llanos_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(pacifico_map)
nac['COD_DPTO'].fillna('Unknown', inplace=True)  # Imputar valores faltantes con 'Unknown'

#2. Descodificando la variable 'AREANAC'

area_map = {1:'Cab Municipal', 2:'Centro poblado', 3: 'Rural disperso', 4:'No Info'}
nac['AREANAC'] = nac['AREANAC'].replace(area_map)

#3. Descodificando la variable 'SEXO'
sexo_map = {1:'M', 2:'F', 3: 'I'}
nac['SEXO'] = nac['SEXO'].replace(sexo_map)

#4. Descodificando la variable 'IDPERTET'
id_map = {1:'Indigena', 2:'Gitano', 3: 'Raizal', 4:'Palenquero', 5:'Afrocolombiano', 6:'Ninguna', 7:'No Info'}
nac['IDPERTET'] = nac['IDPERTET'].replace(id_map)

#5. Descodificando la variable 'EDAD_MADRE'
edadm_map = {1:'10-14', 2:'15-19', 3:'20-24', 4:'25-29', 5:'30-34', 6:'35-39', 7:'40-44', 8:'45-49', 9:'50-54', 99:'No Info'}
nac['EDAD_MADRE'] = nac['EDAD_MADRE'].replace(edadm_map)

#6. Descodificando la variable 'EST_CIVM'
civilm_map = {1:'Union libre >2', 2:'Union libre <2', 3:'Divorciada', 4:'Viuda', 5:'Soltera', 6:'Casada', 9:'No Info'}
nac['EST_CIVM'] = nac['EST_CIVM'].replace(civilm_map)

#7. Descodificando la variable 'NIV_EDM'
#educ_map = {1:'Preescolar', 2:'Primaria', 3:'Secundaria', 4:'Med academica', 5:'Med tecnica', 6:'Normalista', 7:'Tecnica',
             #8:'Tecnologica', 9:'Profesional', 10:'Especializacion', 11:'Maestria', 12:'Doctorado', 13:'Ninguno', 99:'No info' }
#nac['NIV_EDUM'] = nac['NIV_EDUM'].replace(educ_map)

#8. Descodificando la variable 'SEG_SOCIAL'
segsoc_map = {1:'Contributivo', 2:'Subsidiado', 3:'Excepción', 4:'Especial', 5:'No asegurado', 9:'No Info'}
nac['SEG_SOCIAL'] = nac['SEG_SOCIAL'].replace(segsoc_map)

#9. Descodificando la variable 'NIV_EDUP'
nivep_map = {1:'Preescolar', 2:'Primaria', 3:'Secundaria', 4:'Med academica', 5:'Med tecnica', 6:'Normalista', 7:'Tecnica',
            8:'Tecnologica', 9:'Profesional', 10:'Especializacion', 11:'Maestria', 12:'Doctorado', 13:'Ninguno', 99:'No info' }
nac['NIV_EDUP'] = nac['NIV_EDUP'].replace(nivep_map)

nac.head()

"""✍ : 📑 Análisis:



*   La descodificación de las variables nos permite realizar un análisis descriptivo más amplio sobre la naturaleza de las variables objeto de estudio.

## 7. Visualización de datos
"""

# 7.1 Se crea una lista de variables categóricas
catCols = nac.select_dtypes(include = ["object", 'category']).columns.tolist()

nac[catCols].head(2)

# 7.2 Se crea una lista de variables numéricas
numCols=nac.select_dtypes(include = ['float64','int32','int64']).columns.tolist()
nac[numCols].head()

# 7.3 Se visualiza el comportamiento de las variables categóricas
multiple_plot(3, nac , catCols, None, 'countplot', 'Frecuencia de instancias para variables categóricas',30)

"""✍ : 📑 Análisis:



*   Mediante esta grafica podemos visualizar rápidamente cuáles son las categorías más comunes y cuáles son menos frecuentes para cada variable.+
* Se logró identificar patrones y  desequilibrios en los datos categóricos que se están analizando, como por ejemplo la alta frecuencia en los nacimientos para la región Andina, la pertenencia de las madres en su mayoría al regimen subsidiado en salud, entre otras.
"""

# 7.4 Visualización de distribución de cada variable categórica en el conjunto de datos

for col in catCols:
    print("="*5 + f" {col} " + "="*20)
    print(nac[col].value_counts())
    print()

# 7.5 Grafico de cajas y bigotes para visualizar la distribución de la variable COD_DPTO vs. MUL_PARTO
fig, axes = plt.subplots(1, 1, figsize=(6, 3))
ax_cond = axes
sns.boxplot(data=nac_1,
            x='COD_DPTO',
            y='MUL_PARTO',
            ax=axes,
            palette='nipy_spectral',
            zorder=1
            )
# Personalizar el eje x
ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=90)
# Configurar título
ax_cond.set_title('Distribución de la variable COD_DPTO vs. el MUL_PARTO', fontsize=14, fontweight="bold", y=1.1)

"""✍ : 📑 Análisis:



*   Este tipo de visualización permite comparar la distribución de una variable numérica (en este caso, "MUL_PARTO") entre diferentes categorías de otra variable (aquí, "COD_DPTO"). Además, resalta la presencia de valores atípicos y proporciona una idea general de la variabilidad y las tendencias centrales dentro de cada categoría.
* La mayoría de las categorías de "COD_DPTO" tienen una distribución de "MUL_PARTO" concentrada cerca de 2, lo que sugiere que los partos únicos son los más comunes.
* Algunas categorías presentan valores atípicos más altos, lo que indica casos de partos múltiples (gemelos, trillizos, etc.).
* La categoría con código "11" (presumiblemente Bogotá) parece tener la mayor dispersión y más valores atípicos en la variable "MUL_PARTO".
"""

# 7.6 Visualización de variables numéricas con respecto a la multiplicidad del parto
multiple_plot(1, nac , numCols, None, 'scatterplot', 'Relación entre las variables numéricas',30)

"""## 8. Preparación de datos para regresión

Objetivo: Predecir cantidad de partos o nacimientos.
"""

# 8.1 Graficamos la frecuencia mediante un histograma
sns.histplot(x = nac['MUL_PARTO'], stat = "count", binwidth = 0.6, binrange=(1, 9) )
sns.set_style("darkgrid")
plt.xlabel('Cantidad de nacimientos')
plt.ylabel('Frecuencia de nacimientos (2022)')
plt.title('Distribución de nacimientos en 2022')
plt.show()

"""✍ : 📑 Análisis:

* El eje horizontal (x) muestra los diferentes valores de la variable "Cantidad de nacimientos", que van desde 1 hasta 9. Estos valores representan el número de nacimientos en un parto múltiple (1 para un único nacimiento, 2 para gemelos, 3 para trillizos, etc.).
* El eje vertical (y) representa la "Frecuencia de nacimientos (2022)", es decir, la cantidad de veces que ocurrió cada valor de la variable "Cantidad de nacimientos" durante el año 2022.
* La barra azul más alta corresponde al valor 1 en el eje x, lo que indica que la gran mayoría de los nacimientos fueron partos únicos (un solo nacimiento).
* Las demás barras son casi imperceptibles, lo que sugiere que la frecuencia de partos múltiples (gemelos, trillizos, etc.) fue muy baja en comparación con los partos únicos.
* Este histograma muestra una distribución fuertemente sesgada hacia el valor 1, lo que significa que en el año 2022 predominaron ampliamente los nacimientos de un solo bebé, mientras que los partos múltiples fueron casos mucho menos comunes en los datos analizados.
"""

# 8.2 Generamos una matriz de correlación de las variables
matrizCorr = nac_1.drop(['NIV_EDUM', 'MUL_PARTO'], axis=1)
sns.heatmap(matrizCorr.corr(), annot=True, annot_kws={"size": 5}, cmap='coolwarm')
plt.title('Matriz de Correlación')
plt.show()

"""✍ : 📑 Análisis:

* Se observa una alta correlación positiva entre COD_DPTO y AREANAC (0.8032), lo que indica que estas dos variables tienden a aumentar o disminuir juntas.
* Existe una correlación negativa considerable entre SEXO y N_HIJOSV (-0.7609), lo que sugiere que a medida que aumenta una variable, la otra tiende a disminuir.
* La variable MES tiene correlaciones relativamente bajas con la mayoría de las demás variables, excepto con IDPERTET (-0.1317) y EDAD_MADRE (-0.1048).
* Las variables EDAD_PADRE y NIV_EDUP presentan una correlación positiva moderada (0.3317), lo que implica que a medida que aumenta el nivel educativo de los padres, también lo hace su edad.

## Nota:
Es importante tener en cuenta que la correlación no implica necesariamente causalidad y que pueden existir relaciones no lineales que no se captan en esta matriz.

## 9. Preparación de datos para Clusterización

Objetivo: Segmentar clientes basado en la cantidad de nacimientos y nivel de escolaridad
"""

# Análisis exploratorio de datos
sns.scatterplot(x='NIV_EDUM', y='MUL_PARTO', data=nac_1)
plt.show()

# Preparación de datos
nac_1_norm = normalize(nac_1[['NIV_EDUM', 'MUL_PARTO']])

# Creación de datasets
kmeans = KMeans(n_clusters=5, random_state=42)
nac_1['cluster'] = kmeans.fit_predict(nac_1_norm)

# Análisis descriptivo avanzado
sns.scatterplot(x= 'NIV_EDUM', y='MUL_PARTO', hue='cluster', data=nac_1, palette='viridis')
plt.show()

"""Cluster 0 (Sin nacimientos) = Se ubican en niveles educativos >6.

Cluster 1 (1 nacimientos) = Se ubican en niveles educativos

Cluster 2 (2 nacimientos) =

Cluster 3 (3 nacimientos) =

Cluster 4 (4 nacimientos) =

✍ : 📑 Análisis:



*   Se han formado 5 clústeres distintos, identificados por colores diferentes.
*  El clúster 0 contiene la mayoría de las observaciones y se concentra en valores bajos de MUL_PARTO (1-3) y un rango amplio de NIV_EDUM.
* El clúster 1 (puntos azules)  se concentra en niveles educativos más altos (6-12) con una multiplicidad de partos más baja (1-3).
* El clúster 2 (puntos verdes) se caracteriza por valores intermedios de NIV_EDUM (5-9) y una multiplicidad de partos ligeramente más alta (2-5)

**NOTA:** En análisis posteriores se buscará generar los modelos de clasificación con base en los resultados del análisis de regresión. Toda vez, que serpia util verificar previamente cuales variables  tienen una influencia significativa para predecir los nacimientos y por ende la tasa de natalidad. Para así, soportar estadísticamente el análisis planteado en el proyecto y buscar garantizar la efectividad de las clasificaciones generadas
"""