# -*- coding: utf-8 -*-
"""ME03-G09-[1017245947]-[1017185011]

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_Gw7abhVSN5p9U0YD9DjXrDvbxyvMhVw

# Preparaci√≥n del dataset de nacimientos 2022.

## 1. Librerias y configuraciones previas
"""

# Cargar datos con colab
from google.colab import drive
import xml.etree.ElementTree as ET
from google.colab import auth
from pydrive2.auth import GoogleAuth
from pydrive2.drive import GoogleDrive
from oauth2client.client import GoogleCredentials
import os

# Tratamiento de datos
import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler

#Gr√°ficos
import matplotlib.pyplot as plt
from matplotlib import style
import seaborn as sns

# Matem√°ticas y estad√≠sticas
import math

# Preparaci√≥n de datos
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import normalize
from sklearn.cluster import KMeans

# Configuraci√≥n warnings
# ==============================================================================
import warnings
warnings.filterwarnings('ignore')

"""##2. Funciones externas para graficar"""

# Funci√≥n para graficar atributos en barras, pair plot o box-plot
def multiple_plot(ncols, data, columns, target_var, plot_type, title, rot):
   # Paletas de colores y colores de las gr√°ficas
    paletas = ['nipy_spectral','hsv','jet_r','Paired','Set2','Dark2','tab10','husl','mako']
    color = ['steelblue','forestgreen', 'amber']


    # Par√°metros iniciales
    title_dist = 1.1  # Ajusta la distancia vertical del t√≠tulo en el gr√°fico
    x = -1            # Ubicaci√≥n en el eje x del gr√°fico
    y =  0            # Ubicaci√≥n en el eje y del gr√°fico
    nrows = 1         # N√∫mero inicial de filas


    # Ajustar el n√∫mero de filas seg√∫n el tipo de gr√°fico y la cantidad de columnas
    if isinstance(columns, list):
        nrows = math.ceil(len(columns) / ncols)

    # Crear el gr√°fico seg√∫n el tipo especificado
    if ((nrows <= 1 and ncols <= 1) or plot_type == 'scatterplot'):

        # Countplot
        if plot_type == 'countplot':
            # Configurar el gr√°fico countplot
            fig, axes = plt.subplots(1, 1, figsize=(6, 4))
            ax_cond = axes
            sns.countplot(data=data,
                          x=target_var,
                          ax=axes,
                          palette=paletas[0],
                          zorder=1,
                          order=data[target_var].value_counts().index,
                          alpha=0.8
                          )
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar t√≠tulo
            ax_cond.set_title(title, fontsize=14, fontweight="bold", y=title_dist)

        # Boxplot
        elif plot_type == 'boxplot':
            # Configurar el gr√°fico boxplot
            fig, axes = plt.subplots(1, 1, figsize=(6, 4))
            ax_cond = axes
            sns.boxplot(data=data,
                        x=columns,
                        y=target_var,
                        ax=axes,
                        palette=paletas[0],
                        zorder=1
                        )
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar t√≠tulo
            ax_cond.set_title(title, fontsize=14, fontweight="bold", y=title_dist)


        # Scatterplot Matrix (Pairplot)
        elif plot_type == 'scatterplot':
            # Configurar el gr√°fico pairplot
            plot = sns.pairplot(data[columns],
                                palette=paletas[0],
                                diag_kws={'color': color[1]},
                                plot_kws={'color': color[0]},
                                diag_kind='kde'
                                )
            # Ajustar el tama√±o del gr√°fico
            plot.fig.set_size_inches(12, 12)
            # A√±adir un t√≠tulo al pairplot
            plot.fig.suptitle(title, fontsize=14, fontweight="bold")
            # Ajustar el dise√±o para evitar solapamientos
            plt.subplots_adjust(top=0.9)
            # Mostrar el gr√°fico
            plt.show()

    # Graficar m√°s de un subplot
    else:
        # Crear subplots con el n√∫mero especificado de filas y columnas
        fig, axes = plt.subplots(nrows, ncols, figsize=(15, (nrows * 3) + 1))

        for i, column in enumerate(columns):
            x = x + 1

            # Reiniciar x e incrementar y si x alcanza el n√∫mero de columnas
            if x >= ncols:
                y = y + 1
                x = 0

            # Configurar el subplot actual
            if nrows == 1:
                ax_cond = axes[i]
                title_dist = 1.1
            else:
                ax_cond = axes[y, x]

            # Crear el gr√°fico seg√∫n el tipo especificado
            if plot_type == 'countplot':
                # Countplot
                sns.countplot(data=data,
                              x=column,
                              ax=ax_cond,
                              palette=paletas[0],
                              zorder=1,
                              edgecolor='black',
                              linewidth=0.5,
                              order=data[column].value_counts().index
                              )

            elif plot_type == 'boxplot':
                # Boxplot
                sns.boxplot(data=data,
                            x=column,
                            y=target_var,
                            ax=ax_cond,
                            palette=paletas[0],
                            zorder=1
                            )

            # A√±adir cuadr√≠cula en el eje y
            ax_cond.grid(axis='y', zorder=0)
            # Personalizar el eje x
            ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=rot)
            # Configurar t√≠tulo del subplot
            ax_cond.set_title(column, fontsize=10)
            # Ajustar tama√±o de las etiquetas
            ax_cond.tick_params(labelsize=8)
            # Limpiar etiquetas del eje x
            ax_cond.set_xlabel("")

        # Ajustar el dise√±o y el t√≠tulo general del conjunto de subplots
        fig.tight_layout()
        fig.suptitle(title, fontsize=14, fontweight="bold", y=title_dist - 0.15)
        plt.subplots_adjust(top=0.9)

        # Eliminar subplots sin datos si hay m√°s de una fila
        if nrows > 1:
            for ax in axes.flat:
                if not bool(ax.has_data()):
                    fig.delaxes(ax)  # Eliminar si no hay datos en el subplot

"""##3. Carga del conjunto de datos desde google drive

Este dataset extraido del *DANE* (nombrado: **nac2022.csv** ) contiene informaci√≥n sobre los **nacidos vivos para el 2022**, los cuales ser√°n usados para la predicci√≥n de la tasa de natalidad en Colombia, a partir de las diferentes variables.

A continuaci√≥n una breve descripci√≥n de las variables:

****
    
| Campo | Descripci√≥n | Ejemplo |
| :--- | :--- |:--- |
| COD_DPTO | Departamento de Nacimiento  | 17=Caldas |
| COD_MUNIC | Municipio de Nacimiento  | 15= Boyaca |
| AREANAC | √Årea del Nacimiento  | 3 = Rural disperso |
| SIT_PARTO | Sitio de la Parto  | 1= Instituci√≥n de salud |
| OTRO_SIT | Otro sitio, ¬øcu√°l?  | 2 = Domicilio |
| SEXO | Sexo del nacido vivo  | 1= Masculino |
| PESO_NAC | Peso del nacido vivo, al nacer | 1 = Menos de 1.000 |
| TALLA_NAC | Talla del nacido vivo, al nacer  | 1 = Menos de 20 |
| ANO | A√±o de la ocurrencia  | 2022 |
| MES | Mes de la ocurrencia  | 03 = Marzo |
| ATEN_PAR | El parto fue atendido por  | 1 = M√©dico |
| T_GES | Tiempo de gestaci√≥n del nacido vivo  | 2 = De 22 a 27 |
| T_GES_AGRU_CIE | Tiempo de gestaci√≥n del nacido vivo ajustado a la agrupaci√≥n sugerida por la CIE (T_GES_AGRU_CIE)  | 3 = De 28 a 36|
| NUMCONSUL | N√∫mero de consultas prenatales que tuvo la madre del nacido vivo  | 00= Ninguna |
| TIPO_PARTO | Tipo de parto de este nacimiento  | 2 = Ces√°rea |
| MUL_PARTO | Multiplicidad del embarazo  | 3 = Triple |
| APGAR1 | Prueba APGAR al minuto del nacido vivo  | 01 - 10 = Al minuto |
| APGAR2 | Prueba APGAR a los cinco minutos del nacido vivo  | 01 - 10 = A los cinco minutos |
| IDHEMOCLAS | Hemoclasificaci√≥n del nacido vivo: Grupo Sangu√≠neo  | 1 = A |
| IDFACTORRH | Hemoclasificaci√≥n del nacido vivo: Factor RH | 1 = Positivo |
| IDPERTET | De acuerdo con la cultura, pueblo o rasgos f√≠sicos, el nacido vivo es reconocido por sus padres como  | 1 = Ind√≠gena |
| EDAD_MADRE | Edad de la madre a la fecha del parto | 2 = De 15-19 A√±os |
| EST_CIVM | Estado conyugal de la madre  | 4 = Est√° viuda |
| NIV_EDUM | Ultimo nivel de estudio que aprob√≥ la madre  | 2 = B√°sica primaria |
| ULTCURMAD | Ultimo a√±o o grado aprobado de la madre  | 99 = Sin informaci√≥n |
| CODPRES | Pa√≠s de residencia habitual de la madre en el extranjero  | Colombia |
| CODPTORE | Departamento de residencia habitual de la madre | 05 =	Antioquia |
| CODMUNRE | Municipio de residencia habitual de la madre  | 1 = Cabecera municipal |
| AREA_RES | √Årea de residencia habitual de la madre  | 2 = Centro poblado |
| N_HIJOSV | N√∫mero de hijos nacidos vivos que ha tenido la madre, incluido el presente  | 3 = 3 hijos |
| FECHA_NACM | Fecha de nacimiento del anterior hijo nacido vivo  | 99 = Sin informaci√≥n |
| N_EMB | N√∫mero de embarazos, incluido el presente  | 99 = Sin informaci√≥n |
| SEG_SOCIAL | R√©gimen de seguridad social en salud de la madre | 2 = Subsidiado |
| IDCLASADMI | Entidad Administradora en Salud a la que pertenece la madre  | 1 = Entidad promotora de salud |
| EDAD_PADRE | Edad del padre en a√±os cumplidos a la fecha del nacimiento de este hijo  | 999 = Sin informaci√≥n |
| NIV_EDUP | Nivel educativo del padre, ultimo a√±o de estudio que aprob√≥ el padre | 5 = Media t√©cnica |
| ULTCURPAD | Ultimo a√±o o grado aprobado del padre  | 99 = Sin informaci√≥n |
| PROFESION | Profesi√≥n de quien certifica el nacimiento  | 2 = Enfermero(a) |
| TIPOFORMULARIO | Fuente del Certificado  | 1 = Certificado RUAF-ND |

    
****

    
Url origen datos: https://microdatos.dane.gov.co/index.php/catalog/807/data-dictionary/F32?file_name=nac2022
"""

# Autenticaci√≥n y creaci√≥n del cliente PyDrive.
  auth.authenticate_user()
  gauth = GoogleAuth()
  gauth.credentials = GoogleCredentials.get_application_default()
  drive = GoogleDrive(gauth)

  # Carga del dataset de acuerdo a su ubicaci√≥n en google drive  y guardamos en la variable contenido
  downloaded = drive.CreateFile({'id': '1eQB2IcE6WLvL0rIt_AZucnnq0DnsQP-o'})
  contenido = downloaded.GetContentString(encoding='latin1')

  # Imprime el tama√±o en Bytes del archivo compartido
  print("Descargados {} bytes".format(len(contenido)))

  with open("nac2022.csv", "w") as f:
      f.write(contenido)

"""###3.1 Cargar el conjunto de datos en un DataFrame"""

# Se cargan los datos en un DataFrame a partir de un archivo .csv

nac = pd.read_csv("nac2022.csv")
pd.set_option('display.max_columns', None)
print("\n Tabla de datos con informaci√≥n de los nacimientos en 2022:")
nac.head()

"""## 4. Identificaci√≥n de datos"""

# 4.1 Identificando las columnas que tiene la base de datos
nac.columns

# 4.2 Se identifican las variables y su tipo
nac.info()

"""‚úç : üìë An√°lisis:


*   No se identifican valos 'NaN' o nulos en las columnas del DataFrame
*   Se tienen los siguientes tipos  de variables: float64(6), int64(31), object(2)
*   Se tiene un  total de 38 variables

#5. Limpieza de datos
"""

# 5.1 Borrando columnas que no se utilizaran

nac.drop(['COD_MUNIC','SIT_PARTO','OTRO_SIT','PESO_NAC', 'TALLA_NAC','ANO','ATEN_PAR','T_GES','T_GES_AGRU_CIE',
          'NUMCONSUL','TIPO_PARTO', 'APGAR1', 'APGAR2', 'IDHEMOCLAS', 'IDFACTORRH','ULTCURMAD','CODPRES',
          'CODPTORE', 'CODMUNRE','AREA_RES','N_EMB','IDCLASADMI', 'ULTCURPAD', 'PROFESION', 'TIPOFORMULARIO','FECHA_NACM'], axis='columns', inplace=True)
nac.head(10)

"""‚úç : üìë An√°lisis:


*   Se eliminan las variables que a consideraci√≥n del equipo de trabajo no aportan informaci√≥n relevante de acuerdo al objetivo del proyecto planteado. Sin embargo, podr√≠an tenerse en cuenta posteriormente de acuerdo a los resultados derivados de los modelos generados, bien sea como replanteamiento de los mismos o analisis de los resultados.
*   Se elimina un total (26) variables.
*   Se procesar√°n (13) variables.



"""

# 5.2 Se genera un df para la creaci√≥n los datasets de los modelos (sin descodificar variables)
nac_1 = pd.DataFrame(nac)
pd.set_option('display.max_columns', None)
print("\n Tabla de datos con informaci√≥n de los nacimientos en 2022:")

# Se reemplazan las celdas que no contienen informaci√≥n y que est√°n codificadas con 99 y 999
nac_1 = nac_1.replace(99, np.nan)
nac_1 = nac_1.replace(999, np.nan)
nac_1.head()

# 5.3 Se identifican los valores 'NaN' en cada columna
print("Valores nulos por columna:")
print(nac_1.isnull().sum())

# 5.4 Se imputan los valores de la media sobre los valores 'NaN'
nac_1 = nac_1.fillna(nac_1.mean()).round(2)
nac_1

# 5.5 Se verifican de nuevamente los 'NaN' por columna
print("Valores nulos por columna:")
print(nac_1.isnull().sum())

# 5.6 Verificaci√≥n de registros duplicados
nac.loc[nac_1.duplicated()]

"""- **Nota**:

Debido a que para este dataset en particular, se tiene que cada registro es √∫nico por cada nacimiento, no se van a eliminar duplicados porque alterariamos la informaci√≥n contenida.

# 6. Descodificaci√≥n de  variables sobre el dataFrame Original
"""

# 6.1 Reemplazo de c√≥digos en el conjunto de datos

#1. Descodificando la variable 'COD_DPTO' = Codigo departamento
amazonia_map = {18: 'Amazonia', 41: 'Amazonia', 73: 'Amazonia', 86: 'Amazonia', 91: 'Amazonia'}
andina_map = {5: 'Andina', 11: 'Andina', 15: 'Andina', 17: 'Andina', 25: 'Andina', 54 :'Andina',63: 'Andina', 66: 'Andina', 68: 'Andina'}
caribe_map = {8: 'Caribe', 13: 'Caribe', 20: 'Caribe',23: 'Caribe', 44: 'Caribe', 47: 'Caribe', 70: 'Caribe', 88: 'Caribe'}
llanos_map = {50:'Llanos', 81:'Llanos', 85:'Llanos', 94:'Llanos', 95:'Llanos', 97:'Llanos', 99:'Llanos'}
pacifico_map = {19:'Pacifico', 27:'Pacifico', 52:'Pacifico', 76:'Pacifico'}

nac['COD_DPTO'] = nac['COD_DPTO'].replace(amazonia_map)  # Reemplazo de regi√≥n amazonia
nac['COD_DPTO'] = nac['COD_DPTO'].replace(andina_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(caribe_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(llanos_map)
nac['COD_DPTO'] = nac['COD_DPTO'].replace(pacifico_map)
nac['COD_DPTO'].fillna('Unknown', inplace=True)  # Imputar valores faltantes con 'Unknown'

#2. Descodificando la variable 'AREANAC'

area_map = {1:'Cab Municipal', 2:'Centro poblado', 3: 'Rural disperso', 4:'No Info'}
nac['AREANAC'] = nac['AREANAC'].replace(area_map)

#3. Descodificando la variable 'SEXO'
sexo_map = {1:'M', 2:'F', 3: 'I'}
nac['SEXO'] = nac['SEXO'].replace(sexo_map)

#4. Descodificando la variable 'IDPERTET'
id_map = {1:'Indigena', 2:'Gitano', 3: 'Raizal', 4:'Palenquero', 5:'Afrocolombiano', 6:'Ninguna', 7:'No Info'}
nac['IDPERTET'] = nac['IDPERTET'].replace(id_map)

#5. Descodificando la variable 'EDAD_MADRE'
edadm_map = {1:'10-14', 2:'15-19', 3:'20-24', 4:'25-29', 5:'30-34', 6:'35-39', 7:'40-44', 8:'45-49', 9:'50-54', 99:'No Info'}
nac['EDAD_MADRE'] = nac['EDAD_MADRE'].replace(edadm_map)

#6. Descodificando la variable 'EST_CIVM'
civilm_map = {1:'Union libre >2', 2:'Union libre <2', 3:'Divorciada', 4:'Viuda', 5:'Soltera', 6:'Casada', 9:'No Info'}
nac['EST_CIVM'] = nac['EST_CIVM'].replace(civilm_map)

#7. Descodificando la variable 'NIV_EDM'
#educ_map = {1:'Preescolar', 2:'Primaria', 3:'Secundaria', 4:'Med academica', 5:'Med tecnica', 6:'Normalista', 7:'Tecnica',
             #8:'Tecnologica', 9:'Profesional', 10:'Especializacion', 11:'Maestria', 12:'Doctorado', 13:'Ninguno', 99:'No info' }
#nac['NIV_EDUM'] = nac['NIV_EDUM'].replace(educ_map)

#8. Descodificando la variable 'SEG_SOCIAL'
segsoc_map = {1:'Contributivo', 2:'Subsidiado', 3:'Excepci√≥n', 4:'Especial', 5:'No asegurado', 9:'No Info'}
nac['SEG_SOCIAL'] = nac['SEG_SOCIAL'].replace(segsoc_map)

#9. Descodificando la variable 'NIV_EDUP'
nivep_map = {1:'Preescolar', 2:'Primaria', 3:'Secundaria', 4:'Med academica', 5:'Med tecnica', 6:'Normalista', 7:'Tecnica',
            8:'Tecnologica', 9:'Profesional', 10:'Especializacion', 11:'Maestria', 12:'Doctorado', 13:'Ninguno', 99:'No info' }
nac['NIV_EDUP'] = nac['NIV_EDUP'].replace(nivep_map)

nac.head()

"""‚úç : üìë An√°lisis:



*   La descodificaci√≥n de las variables nos permite realizar un an√°lisis descriptivo m√°s amplio sobre la naturaleza de las variables objeto de estudio.

## 7. Visualizaci√≥n de datos
"""

# 7.1 Se crea una lista de variables categ√≥ricas
catCols = nac.select_dtypes(include = ["object", 'category']).columns.tolist()

nac[catCols].head(2)

# 7.2 Se crea una lista de variables num√©ricas
numCols=nac.select_dtypes(include = ['float64','int32','int64']).columns.tolist()
nac[numCols].head()

# 7.3 Se visualiza el comportamiento de las variables categ√≥ricas
multiple_plot(3, nac , catCols, None, 'countplot', 'Frecuencia de instancias para variables categ√≥ricas',30)

"""‚úç : üìë An√°lisis:



*   Mediante esta grafica podemos visualizar r√°pidamente cu√°les son las categor√≠as m√°s comunes y cu√°les son menos frecuentes para cada variable.+
* Se logr√≥ identificar patrones y  desequilibrios en los datos categ√≥ricos que se est√°n analizando, como por ejemplo la alta frecuencia en los nacimientos para la regi√≥n Andina, la pertenencia de las madres en su mayor√≠a al regimen subsidiado en salud, entre otras.
"""

# 7.4 Visualizaci√≥n de distribuci√≥n de cada variable categ√≥rica en el conjunto de datos

for col in catCols:
    print("="*5 + f" {col} " + "="*20)
    print(nac[col].value_counts())
    print()

# 7.5 Grafico de cajas y bigotes para visualizar la distribuci√≥n de la variable COD_DPTO vs. MUL_PARTO
fig, axes = plt.subplots(1, 1, figsize=(6, 3))
ax_cond = axes
sns.boxplot(data=nac_1,
            x='COD_DPTO',
            y='MUL_PARTO',
            ax=axes,
            palette='nipy_spectral',
            zorder=1
            )
# Personalizar el eje x
ax_cond.set_xticklabels(ax_cond.get_xticklabels(), rotation=90)
# Configurar t√≠tulo
ax_cond.set_title('Distribuci√≥n de la variable COD_DPTO vs. el MUL_PARTO', fontsize=14, fontweight="bold", y=1.1)

"""‚úç : üìë An√°lisis:



*   Este tipo de visualizaci√≥n permite comparar la distribuci√≥n de una variable num√©rica (en este caso, "MUL_PARTO") entre diferentes categor√≠as de otra variable (aqu√≠, "COD_DPTO"). Adem√°s, resalta la presencia de valores at√≠picos y proporciona una idea general de la variabilidad y las tendencias centrales dentro de cada categor√≠a.
* La mayor√≠a de las categor√≠as de "COD_DPTO" tienen una distribuci√≥n de "MUL_PARTO" concentrada cerca de 2, lo que sugiere que los partos √∫nicos son los m√°s comunes.
* Algunas categor√≠as presentan valores at√≠picos m√°s altos, lo que indica casos de partos m√∫ltiples (gemelos, trillizos, etc.).
* La categor√≠a con c√≥digo "11" (presumiblemente Bogot√°) parece tener la mayor dispersi√≥n y m√°s valores at√≠picos en la variable "MUL_PARTO".
"""

# 7.6 Visualizaci√≥n de variables num√©ricas con respecto a la multiplicidad del parto
multiple_plot(1, nac , numCols, None, 'scatterplot', 'Relaci√≥n entre las variables num√©ricas',30)

"""## 8. Preparaci√≥n de datos para regresi√≥n

Objetivo: Predecir cantidad de partos o nacimientos.
"""

# 8.1 Graficamos la frecuencia mediante un histograma
sns.histplot(x = nac['MUL_PARTO'], stat = "count", binwidth = 0.6, binrange=(1, 9) )
sns.set_style("darkgrid")
plt.xlabel('Cantidad de nacimientos')
plt.ylabel('Frecuencia de nacimientos (2022)')
plt.title('Distribuci√≥n de nacimientos en 2022')
plt.show()

"""‚úç : üìë An√°lisis:

* El eje horizontal (x) muestra los diferentes valores de la variable "Cantidad de nacimientos", que van desde 1 hasta 9. Estos valores representan el n√∫mero de nacimientos en un parto m√∫ltiple (1 para un √∫nico nacimiento, 2 para gemelos, 3 para trillizos, etc.).
* El eje vertical (y) representa la "Frecuencia de nacimientos (2022)", es decir, la cantidad de veces que ocurri√≥ cada valor de la variable "Cantidad de nacimientos" durante el a√±o 2022.
* La barra azul m√°s alta corresponde al valor 1 en el eje x, lo que indica que la gran mayor√≠a de los nacimientos fueron partos √∫nicos (un solo nacimiento).
* Las dem√°s barras son casi imperceptibles, lo que sugiere que la frecuencia de partos m√∫ltiples (gemelos, trillizos, etc.) fue muy baja en comparaci√≥n con los partos √∫nicos.
* Este histograma muestra una distribuci√≥n fuertemente sesgada hacia el valor 1, lo que significa que en el a√±o 2022 predominaron ampliamente los nacimientos de un solo beb√©, mientras que los partos m√∫ltiples fueron casos mucho menos comunes en los datos analizados.
"""

# 8.2 Generamos una matriz de correlaci√≥n de las variables
matrizCorr = nac_1.drop(['NIV_EDUM', 'MUL_PARTO'], axis=1)
sns.heatmap(matrizCorr.corr(), annot=True, annot_kws={"size": 5}, cmap='coolwarm')
plt.title('Matriz de Correlaci√≥n')
plt.show()

"""‚úç : üìë An√°lisis:

* Se observa una alta correlaci√≥n positiva entre COD_DPTO y AREANAC (0.8032), lo que indica que estas dos variables tienden a aumentar o disminuir juntas.
* Existe una correlaci√≥n negativa considerable entre SEXO y N_HIJOSV (-0.7609), lo que sugiere que a medida que aumenta una variable, la otra tiende a disminuir.
* La variable MES tiene correlaciones relativamente bajas con la mayor√≠a de las dem√°s variables, excepto con IDPERTET (-0.1317) y EDAD_MADRE (-0.1048).
* Las variables EDAD_PADRE y NIV_EDUP presentan una correlaci√≥n positiva moderada (0.3317), lo que implica que a medida que aumenta el nivel educativo de los padres, tambi√©n lo hace su edad.

## Nota:
Es importante tener en cuenta que la correlaci√≥n no implica necesariamente causalidad y que pueden existir relaciones no lineales que no se captan en esta matriz.

## 9. Preparaci√≥n de datos para Clusterizaci√≥n

Objetivo: Segmentar clientes basado en la cantidad de nacimientos y nivel de escolaridad
"""

# An√°lisis exploratorio de datos
sns.scatterplot(x='NIV_EDUM', y='MUL_PARTO', data=nac_1)
plt.show()

# Preparaci√≥n de datos
nac_1_norm = normalize(nac_1[['NIV_EDUM', 'MUL_PARTO']])

# Creaci√≥n de datasets
kmeans = KMeans(n_clusters=5, random_state=42)
nac_1['cluster'] = kmeans.fit_predict(nac_1_norm)

# An√°lisis descriptivo avanzado
sns.scatterplot(x= 'NIV_EDUM', y='MUL_PARTO', hue='cluster', data=nac_1, palette='viridis')
plt.show()

"""Cluster 0 (Sin nacimientos) = Se ubican en niveles educativos >6.

Cluster 1 (1 nacimientos) = Se ubican en niveles educativos

Cluster 2 (2 nacimientos) =

Cluster 3 (3 nacimientos) =

Cluster 4 (4 nacimientos) =

‚úç : üìë An√°lisis:



*   Se han formado 5 cl√∫steres distintos, identificados por colores diferentes.
*  El cl√∫ster 0 contiene la mayor√≠a de las observaciones y se concentra en valores bajos de MUL_PARTO (1-3) y un rango amplio de NIV_EDUM.
* El cl√∫ster 1 (puntos azules)  se concentra en niveles educativos m√°s altos (6-12) con una multiplicidad de partos m√°s baja (1-3).
* El cl√∫ster 2 (puntos verdes) se caracteriza por valores intermedios de NIV_EDUM (5-9) y una multiplicidad de partos ligeramente m√°s alta (2-5)

**NOTA:** En an√°lisis posteriores se buscar√° generar los modelos de clasificaci√≥n con base en los resultados del an√°lisis de regresi√≥n. Toda vez, que serpia util verificar previamente cuales variables  tienen una influencia significativa para predecir los nacimientos y por ende la tasa de natalidad. Para as√≠, soportar estad√≠sticamente el an√°lisis planteado en el proyecto y buscar garantizar la efectividad de las clasificaciones generadas
"""